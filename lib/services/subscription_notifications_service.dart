import 'package:flutter/material.dart';
import 'subscription_service.dart';

/// ูููุฐุฌ ุจูุงูุงุช ุงูุฅุดุนุงุฑ
class NotificationData {
  final String id;
  final String title;
  final String body;
  final DateTime timestamp;
  final NotificationType type;
  final bool isRead;
  
  NotificationData({
    required this.id,
    required this.title,
    required this.body,
    required this.timestamp,
    required this.type,
    this.isRead = false,
  });
  
  NotificationData copyWith({
    String? id,
    String? title,
    String? body,
    DateTime? timestamp,
    NotificationType? type,
    bool? isRead,
  }) {
    return NotificationData(
      id: id ?? this.id,
      title: title ?? this.title,
      body: body ?? this.body,
      timestamp: timestamp ?? this.timestamp,
      type: type ?? this.type,
      isRead: isRead ?? this.isRead,
    );
  }
}

enum NotificationType {
  expiry,
  activation,
  renewal,
  offer,
  warning,
}

/// ุฎุฏูุฉ ุฅุฏุงุฑุฉ ุฅุดุนุงุฑุงุช ุงูุงุดุชุฑุงูุงุช (ูุณุฎุฉ ูุจุณุทุฉ)
class SubscriptionNotificationsService {
  static final List<NotificationData> _notifications = [];
  static final ValueNotifier<int> unreadCount = ValueNotifier(0);
  static final ValueNotifier<List<NotificationData>> notificationsNotifier = 
      ValueNotifier([]);
  
  /// ุชููุฆุฉ ูุธุงู ุงูุฅุดุนุงุฑุงุช
  static Future<void> initialize() async {
    try {
      debugPrint('โ ุชู ุชููุฆุฉ ูุธุงู ุงูุฅุดุนุงุฑุงุช ุจูุฌุงุญ');
    } catch (e) {
      debugPrint('โ ุฎุทุฃ ูู ุชููุฆุฉ ุงูุฅุดุนุงุฑุงุช: $e');
    }
  }
  
  /// ูุญุต ูุฅุฑุณุงู ุฅุดุนุงุฑุงุช ุงูุชูุงุก ุงูุงุดุชุฑุงู
  static Future<void> checkAndSendExpirationNotifications() async {
    try {
      final status = await SubscriptionService.getReportsSyncStatus();
      
      if (status.isActive && status.daysRemaining != null) {
        final daysRemaining = status.daysRemaining!;
        
        // ุฅุดุนุงุฑ ูุจู 7 ุฃูุงู
        if (daysRemaining == 7) {
          await _addNotification(
            'ุชูุจูู ุงุดุชุฑุงู ูุฒุงููุฉ ุงูุชูุงุฑูุฑ',
            'ุณููุชูู ุงุดุชุฑุงูู ุฎูุงู 7 ุฃูุงู. ุฌุฏุฏ ุงูุขู ูุชุฌูุจ ุงููุทุงุน ุงูุฎุฏูุฉ.',
            NotificationType.warning,
            'expiry_7_days',
          );
        }
        
        // ุฅุดุนุงุฑ ูุจู 3 ุฃูุงู
        if (daysRemaining == 3) {
          await _addNotification(
            'ุชุญุฐูุฑ: ุงูุชูุงุก ุงูุงุดุชุฑุงู ูุฑูุจ',
            'ุณููุชูู ุงุดุชุฑุงู ูุฒุงููุฉ ุงูุชูุงุฑูุฑ ุฎูุงู 3 ุฃูุงู ููุท!',
            NotificationType.warning,
            'expiry_3_days',
          );
        }
        
        // ุฅุดุนุงุฑ ูุจู ููู ูุงุญุฏ
        if (daysRemaining == 1) {
          await _addNotification(
            'ุฅูุฐุงุฑ ุฃุฎูุฑ: ุงูุชูุงุก ุงูุงุดุชุฑุงู ุบุฏุงู',
            'ุณููุชูู ุงุดุชุฑุงู ูุฒุงููุฉ ุงูุชูุงุฑูุฑ ุบุฏุงู. ุฌุฏุฏ ุงูุขู!',
            NotificationType.expiry,
            'expiry_1_day',
          );
        }
      }
    } catch (e) {
      debugPrint('ุฎุทุฃ ูู ูุญุต ุฅุดุนุงุฑุงุช ุงูุงุดุชุฑุงู: $e');
    }
  }
  
  /// ุฅุฑุณุงู ุฅุดุนุงุฑ ูุฌุงุญ ุงูุชูุนูู
  static Future<void> sendActivationSuccessNotification() async {
    await _addNotification(
      'ุชู ุชูุนูู ุงูุงุดุชุฑุงู ุจูุฌุงุญ! ๐',
      'ููููู ุงูุขู ุงูุงุณุชูุชุงุน ุจูุฒุงููุฉ ุงูุชูุงุฑูุฑ ุงูุณุญุงุจูุฉ ููุฏุฉ 30 ููู.',
      NotificationType.activation,
      'activation_success',
    );
  }
  
  /// ุฅุฑุณุงู ุฅุดุนุงุฑ ุงูุชูุงุก ุงูุงุดุชุฑุงู
  static Future<void> sendExpirationNotification() async {
    await _addNotification(
      'ุงูุชูู ุงุดุชุฑุงู ูุฒุงููุฉ ุงูุชูุงุฑูุฑ',
      'ุชู ุฅููุงู ูุฒุงููุฉ ุงูุชูุงุฑูุฑ ุงูุณุญุงุจูุฉ. ุฌุฏุฏ ุงุดุชุฑุงูู ูุงุณุชุนุงุฏุฉ ุงูุฎุฏูุฉ.',
      NotificationType.expiry,
      'subscription_expired',
    );
  }
  
  /// ุฅุฑุณุงู ุฅุดุนุงุฑ ุชุฐููุฑ ุจุงูุชุฌุฏูุฏ
  static Future<void> sendRenewalReminderNotification(int daysRemaining) async {
    await _addNotification(
      'ุชุฐููุฑ ุจุชุฌุฏูุฏ ุงูุงุดุชุฑุงู',
      'ูุชุจูู $daysRemaining ุฃูุงู ุนูู ุงูุชูุงุก ุงุดุชุฑุงู ูุฒุงููุฉ ุงูุชูุงุฑูุฑ. ุฌุฏุฏ ุงุดุชุฑุงูู ุงูุขู.',
      NotificationType.renewal,
      'renewal_reminder_$daysRemaining',
    );
  }
  
  /// ุฅุฑุณุงู ุฅุดุนุงุฑ ุนุฑุถ ุฎุงุต
  static Future<void> sendSpecialOfferNotification(String offerTitle, String offerDescription) async {
    await _addNotification(
      'ุนุฑุถ ุฎุงุต: $offerTitle',
      offerDescription,
      NotificationType.offer,
      'special_offer_${DateTime.now().millisecondsSinceEpoch}',
    );
  }
  
  /// ุฅุถุงูุฉ ุฅุดุนุงุฑ ุฌุฏูุฏ
  static Future<void> _addNotification(
    String title, 
    String body, 
    NotificationType type, 
    String id
  ) async {
    try {
      // ุชุญูู ูู ุนุฏู ูุฌูุฏ ุฅุดุนุงุฑ ุจููุณ ุงูู ID
      final existingIndex = _notifications.indexWhere((n) => n.id == id);
      
      final notification = NotificationData(
        id: id,
        title: title,
        body: body,
        timestamp: DateTime.now(),
        type: type,
      );
      
      if (existingIndex != -1) {
        _notifications[existingIndex] = notification;
      } else {
        _notifications.insert(0, notification);
      }
      
      // ุชุญุฏูุซ ุงูุนุฏุงุฏุงุช
      _updateNotifiers();
      
      debugPrint('โ ุชู ุฅุถุงูุฉ ุฅุดุนุงุฑ: $title');
    } catch (e) {
      debugPrint('โ ุฎุทุฃ ูู ุฅุถุงูุฉ ุงูุฅุดุนุงุฑ: $e');
    }
  }
  
  /// ุงูุญุตูู ุนูู ุฌููุน ุงูุฅุดุนุงุฑุงุช
  static List<NotificationData> getAllNotifications() {
    return List.from(_notifications);
  }
  
  /// ุงูุญุตูู ุนูู ุงูุฅุดุนุงุฑุงุช ุบูุฑ ุงูููุฑูุกุฉ
  static List<NotificationData> getUnreadNotifications() {
    return _notifications.where((n) => !n.isRead).toList();
  }
  
  /// ุนุฏุฏ ุงูุฅุดุนุงุฑุงุช ุบูุฑ ุงูููุฑูุกุฉ
  static int getUnreadCount() {
    return _notifications.where((n) => !n.isRead).length;
  }
  
  /// ุชุญุฏูุฏ ุฅุดุนุงุฑ ูููุฑูุก
  static void markAsRead(String notificationId) {
    final index = _notifications.indexWhere((n) => n.id == notificationId);
    if (index != -1) {
      _notifications[index] = _notifications[index].copyWith(isRead: true);
      _updateNotifiers();
    }
  }
  
  /// ุชุญุฏูุฏ ุฌููุน ุงูุฅุดุนุงุฑุงุช ูููุฑูุกุฉ
  static void markAllAsRead() {
    for (int i = 0; i < _notifications.length; i++) {
      _notifications[i] = _notifications[i].copyWith(isRead: true);
    }
    _updateNotifiers();
  }
  
  /// ุญุฐู ุฅุดุนุงุฑ
  static void deleteNotification(String notificationId) {
    _notifications.removeWhere((n) => n.id == notificationId);
    _updateNotifiers();
  }
  
  /// ุญุฐู ุฌููุน ุงูุฅุดุนุงุฑุงุช
  static void deleteAllNotifications() {
    _notifications.clear();
    _updateNotifiers();
  }
  
  /// ุญุฐู ุงูุฅุดุนุงุฑุงุช ุงููุฏููุฉ (ุฃูุซุฑ ูู 30 ููู)
  static void deleteOldNotifications() {
    final thirtyDaysAgo = DateTime.now().subtract(Duration(days: 30));
    _notifications.removeWhere((n) => n.timestamp.isBefore(thirtyDaysAgo));
    _updateNotifiers();
  }
  
  /// ุชุญุฏูุซ ุงููุฑุงูุจุงุช
  static void _updateNotifiers() {
    unreadCount.value = getUnreadCount();
    notificationsNotifier.value = List.from(_notifications);
  }
  
  /// ุฅูุดุงุก widget ูุนุฑุถ ุดุงุฑุฉ ุงูุฅุดุนุงุฑุงุช
  static Widget buildNotificationBadge({
    required Widget child,
    Color? badgeColor,
    Color? textColor,
  }) {
    return ValueListenableBuilder<int>(
      valueListenable: unreadCount,
      builder: (context, count, _) {
        if (count == 0) return child;
        
        return Stack(
          children: [
            child,
            Positioned(
              right: 0,
              top: 0,
              child: Container(
                padding: EdgeInsets.all(2),
                decoration: BoxDecoration(
                  color: badgeColor ?? Colors.red,
                  borderRadius: BorderRadius.circular(10),
                ),
                constraints: BoxConstraints(
                  minWidth: 16,
                  minHeight: 16,
                ),
                child: Text(
                  count > 99 ? '99+' : count.toString(),
                  style: TextStyle(
                    color: textColor ?? Colors.white,
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            ),
          ],
        );
      },
    );
  }
  
  /// ุฅูุดุงุก widget ูุนุฑุถ ูุงุฆูุฉ ุงูุฅุดุนุงุฑุงุช
  static Widget buildNotificationsList({
    EdgeInsetsGeometry? padding,
    void Function(NotificationData)? onNotificationTap,
  }) {
    return ValueListenableBuilder<List<NotificationData>>(
      valueListenable: notificationsNotifier,
      builder: (context, notifications, _) {
        if (notifications.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.notifications_none, size: 64, color: Colors.grey),
                SizedBox(height: 16),
                Text(
                  'ูุง ุชูุฌุฏ ุฅุดุนุงุฑุงุช',
                  style: TextStyle(fontSize: 16, color: Colors.grey[600]),
                ),
              ],
            ),
          );
        }
        
        return ListView.builder(
          padding: padding ?? EdgeInsets.all(8),
          itemCount: notifications.length,
          itemBuilder: (context, index) {
            final notification = notifications[index];
            return _buildNotificationTile(
              notification, 
              onTap: onNotificationTap,
            );
          },
        );
      },
    );
  }
  
  static Widget _buildNotificationTile(
    NotificationData notification, {
    void Function(NotificationData)? onTap,
  }) {
    IconData iconData;
    Color iconColor;
    
    switch (notification.type) {
      case NotificationType.expiry:
        iconData = Icons.warning;
        iconColor = Colors.red;
        break;
      case NotificationType.activation:
        iconData = Icons.check_circle;
        iconColor = Colors.green;
        break;
      case NotificationType.renewal:
        iconData = Icons.refresh;
        iconColor = Colors.blue;
        break;
      case NotificationType.offer:
        iconData = Icons.local_offer;
        iconColor = Colors.orange;
        break;
      case NotificationType.warning:
        iconData = Icons.warning_amber;
        iconColor = Colors.orange;
        break;
    }
    
    return Card(
      margin: EdgeInsets.symmetric(vertical: 4, horizontal: 8),
      color: notification.isRead ? Colors.grey[50] : Colors.white,
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: iconColor.withOpacity(0.1),
          child: Icon(iconData, color: iconColor),
        ),
        title: Text(
          notification.title,
          style: TextStyle(
            fontWeight: notification.isRead ? FontWeight.normal : FontWeight.bold,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(notification.body),
            SizedBox(height: 4),
            Text(
              _formatTime(notification.timestamp),
              style: TextStyle(fontSize: 12, color: Colors.grey[600]),
            ),
          ],
        ),
        trailing: notification.isRead
            ? null
            : Container(
                width: 8,
                height: 8,
                decoration: BoxDecoration(
                  color: Colors.blue,
                  shape: BoxShape.circle,
                ),
              ),
        onTap: () {
          if (!notification.isRead) {
            markAsRead(notification.id);
          }
          onTap?.call(notification);
        },
      ),
    );
  }
  
  static String _formatTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);
    
    if (difference.inMinutes < 1) {
      return 'ุงูุขู';
    } else if (difference.inHours < 1) {
      return 'ููุฐ ${difference.inMinutes} ุฏูููุฉ';
    } else if (difference.inDays < 1) {
      return 'ููุฐ ${difference.inHours} ุณุงุนุฉ';
    } else if (difference.inDays < 7) {
      return 'ููุฐ ${difference.inDays} ููู';
    } else {
      return '${time.day}/${time.month}/${time.year}';
    }
  }
}
